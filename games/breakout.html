<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <style>
        body {
            background: #222;
            color: #fff;
            font-family: 'Press Start 2P', monospace, cursive;
            min-height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #181818;
            border-radius: 16px;
            box-shadow: 0 0 32px #0ff8, 0 0 8px #000a;
            padding: 32px 32px 16px 32px;
            margin-top: 40px;
        }
        .scoreboard {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            justify-content: center;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            font-family: 'Press Start 2P', monospace, cursive;
            background: #111;
            border: 2px solid #0ff;
            border-radius: 8px;
            padding: 8px 16px;
            color: #fff;
            box-shadow: 0 0 8px #0ff4;
            text-align: center;
        }
        .achievements {
            background: #111;
            border: 2px solid #0f0;
            border-radius: 8px;
            padding: 8px 16px;
            margin: 8px 0;
            font-size: 8px;
            color: #0f0;
            text-align: center;
            min-height: 30px;
        }
        .achievement {
            display: inline-block;
            margin: 2px;
            padding: 3px 6px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 4px;
            opacity: 0.3;
            transition: all 0.3s ease;
        }
        .achievement.unlocked {
            background: #0f0;
            color: #222;
            opacity: 1;
            animation: achievementGlow 0.8s ease-in-out;
        }
        @keyframes achievementGlow {
            0% { transform: scale(1); box-shadow: 0 0 4px #0f0; }
            50% { transform: scale(1.1); box-shadow: 0 0 12px #0f0; }
            100% { transform: scale(1); box-shadow: 0 0 6px #0f0; }
        }
        .power-up {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: powerUpFall 3s linear;
        }
        @keyframes powerUpFall {
            from { transform: translateY(0) rotate(0deg); }
            to { transform: translateY(300px) rotate(360deg); }
        }
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.95);
            color: #222;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 10px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        .notification.show {
            opacity: 1;
            animation: slideDown 0.3s ease-out;
        }
        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-100%); }
            to { transform: translateX(-50%) translateY(0); }
        }
        .combo {
            position: absolute;
            color: #ff0;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            animation: comboFloat 1s ease-out forwards;
        }
        @keyframes comboFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
        }
        .btn {
            background: #0ff;
            color: #222;
            border: none;
            border-radius: 6px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 6px 12px;
            margin: 4px 2px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn:hover {
            background: #ff0;
            transform: translateY(-1px);
        }
        .controls {
            margin: 8px 0;
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }
        #breakoutCanvas {
            background: #111;
            border: 6px solid #0ff;
            border-radius: 8px;
            image-rendering: pixelated;
            box-shadow: 0 0 24px #0ff8;
            margin-bottom: 16px;
            display: block;
        }
        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px #0ff, 0 0 8px #0ff8;
            letter-spacing: 2px;
        }
        .instructions {
            background: #222;
            border: 2px solid #0ff;
            border-radius: 8px;
            padding: 10px 18px;
            margin-top: 10px;
            font-size: 12px;
            color: #fff;
            text-align: center;
            box-shadow: 0 0 8px #0ff4;
        }
        .instructions span {
            color: #0ff;
        }
        a.menu-link {
            color: #0ff;
            display: block;
            margin: 12px 0;
            text-align: center;
            text-decoration: none;
        }
        a.menu-link:hover {
            text-decoration: underline;
        }
        footer {
            margin-top: 24px;
            color: #0ff;
            font-size: 10px;
            text-align: center;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Breakout</h1>
        <div class="scoreboard">
            <span id="score">Score: 0</span>
            <span id="lives">Lives: 5</span>
            <span id="level">Level: 1</span>
            <span id="combo">Combo: x1</span>
        </div>
        
        <div class="achievements">
            <div>üèÜ Achievements</div>
            <div id="achievementList">
                <span class="achievement" id="firstLevel">First Clear</span>
                <span class="achievement" id="perfectLevel">Perfect Level</span>
                <span class="achievement" id="comboMaster">Combo Master</span>
                <span class="achievement" id="speedRunner">Speed Runner</span>
                <span class="achievement" id="powerUpCollector">Power-Up Pro</span>
                <span class="achievement" id="survivor">Survivor</span>
            </div>
        </div>

        <canvas id="breakoutCanvas" width="400" height="300"></canvas>
        
        <div class="controls">
            <button class="btn" onclick="pauseGame()">Pause</button>
            <button class="btn" onclick="toggleSound()">üîä</button>
            <button class="btn" onclick="resetGame()">Restart</button>
        </div>
        
        <div class="instructions">
            <p>
                Use <span>Left/Right Arrows</span> or <span>A/D</span> to move<br>
                Collect <span>power-ups</span> for special abilities!<br>
                <b>Press <span>Space</span> to pause ‚Ä¢ <span>R</span> to restart</b>
            </p>
        </div>
        <a class="menu-link" href="../public/arcade.html">&#8592; Back to Menu</a>
    </div>
    
    <div class="notification" id="notification"></div>
    <footer>
        <p>&copy; 2025 Your Name</p>
    </footer>
    <script>
    // Enhanced sound system
    let soundEnabled = true;
    let audioContext;
    
    function initAudio() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
    }
    
    function playSound(type, frequency = 440, duration = 100) {
        if (!soundEnabled || !audioContext) return;
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        switch(type) {
            case 'brick':
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration/1000);
                break;
            case 'paddle':
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(frequency * 1.5, audioContext.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                break;
            case 'powerup':
                for(let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.setValueAtTime(440 * Math.pow(2, i/4), audioContext.currentTime);
                        gain.gain.setValueAtTime(0.08, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.2);
                    }, i * 50);
                }
                return;
            case 'levelup':
                for(let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.setValueAtTime(523 * Math.pow(2, i/5), audioContext.currentTime);
                        gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.3);
                    }, i * 100);
                }
                return;
        }
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration/1000);
    }
    
    function toggleSound() {
        soundEnabled = !soundEnabled;
        const btn = document.querySelector('.btn:nth-child(2)');
        btn.textContent = soundEnabled ? 'üîä' : 'üîá';
        showNotification(soundEnabled ? 'Sound ON' : 'Sound OFF');
    }

    const canvas = document.getElementById('breakoutCanvas');
    const ctx = canvas.getContext('2d');

    // Enhanced game settings
    const paddleWidth = 90, paddleHeight = 10, paddleSpeed = 7;
    const ballRadius = 7;
    const brickRowCountBase = 5, brickColCount = 8;
    const brickWidth = 40, brickHeight = 16, brickPadding = 6, brickOffsetTop = 40, brickOffsetLeft = 18;
    const maxLevel = 15;

    // Game state
    let paddleX, ballX, ballY, ballDX, ballDY, rightPressed, leftPressed, aPressed, dPressed;
    let bricks, score, lives, gameOver, win, level, brickRowCount, ballSpeed;
    let paused = false, gameStarted = false;
    let levelStartTime, currentPaddleWidth, paddleBoostTime = 0, multiballTime = 0;
    let stickyPaddle = false, stickyTime = 0, ballStuck = false;
    
    // Power-ups and effects
    let powerUps = [];
    let particles = [];
    let balls = [];
    let comboCount = 1, comboTime = 0, lastHitTime = 0;
    let screenShake = 0, shakeDecay = 0.9;
    
    // Statistics and achievements
    let stats = {
        gamesPlayed: 0,
        levelsCompleted: 0,
        bricksDestroyed: 0,
        powerUpsCollected: 0,
        perfectLevels: 0,
        bestScore: 0,
        fastestLevel: null
    };
    
    let achievements = {
        firstLevel: false,
        perfectLevel: false,
        comboMaster: false,
        speedRunner: false,
        powerUpCollector: false,
        survivor: false
    };
    
    // Power-up types
    const POWERUP_TYPES = {
        MULTIBALL: { color: '#ff0', symbol: '‚óâ', duration: 0 },
        BIGGER_PADDLE: { color: '#0f0', symbol: '‚ñ¨', duration: 10000 },
        STICKY_PADDLE: { color: '#f0f', symbol: '‚¨¢', duration: 15000 },
        EXTRA_LIFE: { color: '#f00', symbol: '‚ô•', duration: 0 },
        SLOW_BALL: { color: '#0ff', symbol: '‚ö¨', duration: 8000 },
        POINTS: { color: '#fa0', symbol: '‚òÖ', duration: 0 }
    };

    // Load saved data
    function loadData() {
        const savedStats = localStorage.getItem('breakoutStats');
        const savedAchievements = localStorage.getItem('breakoutAchievements');
        const savedSound = localStorage.getItem('breakoutSound');
        
        if (savedStats) stats = {...stats, ...JSON.parse(savedStats)};
        if (savedAchievements) achievements = {...achievements, ...JSON.parse(savedAchievements)};
        if (savedSound !== null) soundEnabled = JSON.parse(savedSound);
        
        updateAchievementsDisplay();
    }
    
    function saveData() {
        localStorage.setItem('breakoutStats', JSON.stringify(stats));
        localStorage.setItem('breakoutAchievements', JSON.stringify(achievements));
        localStorage.setItem('breakoutSound', JSON.stringify(soundEnabled));
    }
    
    // Notifications
    function showNotification(message, duration = 2000) {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.className = 'notification show';
        
        setTimeout(() => {
            notification.className = 'notification';
        }, duration);
    }
    
    // Particle system
    function createParticles(x, y, color, count = 5) {
        for(let i = 0; i < count; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 30,
                maxLife: 30,
                color: color,
                size: Math.random() * 3 + 1
            });
        }
    }
    
    function updateParticles() {
        particles = particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.2; // gravity
            p.life--;
            return p.life > 0;
        });
    }
    
    function drawParticles() {
        particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.life / p.maxLife;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
            ctx.restore();
        });
    }
    
    // Combo system
    function showCombo(x, y) {
        if (comboCount > 1) {
            const comboElement = document.createElement('div');
            comboElement.className = 'combo';
            comboElement.textContent = `${comboCount}x COMBO!`;
            comboElement.style.left = x + 'px';
            comboElement.style.top = y + 'px';
            document.body.appendChild(comboElement);
            
            setTimeout(() => {
                document.body.removeChild(comboElement);
            }, 1000);
        }
    }
    
    // Power-up system
    function createPowerUp(x, y) {
        if (Math.random() < 0.15) { // 15% chance
            const types = Object.keys(POWERUP_TYPES);
            const type = types[Math.floor(Math.random() * types.length)];
            
            powerUps.push({
                x: x,
                y: y,
                type: type,
                speed: 1,
                collected: false
            });
        }
    }
    
    function updatePowerUps() {
        powerUps = powerUps.filter(powerUp => {
            powerUp.y += powerUp.speed;
            
            // Check collision with paddle
            if (!powerUp.collected &&
                powerUp.y + 10 > canvas.height - paddleHeight - 10 &&
                powerUp.x > paddleX && powerUp.x < paddleX + currentPaddleWidth) {
                
                collectPowerUp(powerUp.type);
                powerUp.collected = true;
                createParticles(powerUp.x, powerUp.y, POWERUP_TYPES[powerUp.type].color, 8);
                return false;
            }
            
            return powerUp.y < canvas.height;
        });
    }
    
    function collectPowerUp(type) {
        stats.powerUpsCollected++;
        playSound('powerup');
        
        switch(type) {
            case 'MULTIBALL':
                if (balls.length === 0) {
                    // Create additional balls
                    for(let i = 0; i < 2; i++) {
                        balls.push({
                            x: ballX + (i-0.5) * 20,
                            y: ballY,
                            dx: ballDX * (0.8 + Math.random() * 0.4),
                            dy: ballDY * (0.8 + Math.random() * 0.4)
                        });
                    }
                    multiballTime = Date.now() + 15000;
                }
                showNotification('MULTIBALL!');
                break;
                
            case 'BIGGER_PADDLE':
                currentPaddleWidth = paddleWidth * 1.5;
                paddleBoostTime = Date.now() + POWERUP_TYPES[type].duration;
                showNotification('BIGGER PADDLE!');
                break;
                
            case 'STICKY_PADDLE':
                stickyPaddle = true;
                stickyTime = Date.now() + POWERUP_TYPES[type].duration;
                showNotification('STICKY PADDLE!');
                break;
                
            case 'EXTRA_LIFE':
                lives++;
                updateScoreboard();
                showNotification('EXTRA LIFE!');
                break;
                
            case 'SLOW_BALL':
                ballSpeed *= 0.7;
                ballDX *= 0.7;
                ballDY *= 0.7;
                setTimeout(() => {
                    ballSpeed /= 0.7;
                    ballDX /= 0.7;
                    ballDY /= 0.7;
                }, POWERUP_TYPES[type].duration);
                showNotification('SLOW BALL!');
                break;
                
            case 'POINTS':
                score += 100;
                updateScoreboard();
                showNotification('+100 POINTS!');
                break;
        }
    }
    
    function drawPowerUps() {
        powerUps.forEach(powerUp => {
            const config = POWERUP_TYPES[powerUp.type];
            ctx.fillStyle = config.color;
            ctx.beginPath();
            ctx.arc(powerUp.x, powerUp.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(config.symbol, powerUp.x, powerUp.y + 4);
        });
    }
    
    // Achievement system
    function checkAchievements() {
        let newAchievements = [];
        
        if (!achievements.firstLevel && stats.levelsCompleted >= 1) {
            achievements.firstLevel = true;
            newAchievements.push('First Clear - Completed your first level!');
        }
        
        if (!achievements.comboMaster && comboCount >= 5) {
            achievements.comboMaster = true;
            newAchievements.push('Combo Master - 5x combo achieved!');
        }
        
        if (!achievements.powerUpCollector && stats.powerUpsCollected >= 10) {
            achievements.powerUpCollector = true;
            newAchievements.push('Power-Up Pro - Collected 10 power-ups!');
        }
        
        if (!achievements.survivor && level >= 5) {
            achievements.survivor = true;
            newAchievements.push('Survivor - Reached level 5!');
        }
        
        newAchievements.forEach((msg, index) => {
            setTimeout(() => {
                showNotification(msg, 3000);
            }, index * 1000);
        });
        
        updateAchievementsDisplay();
        saveData();
    }
    
    function updateAchievementsDisplay() {
        Object.keys(achievements).forEach(key => {
            const element = document.getElementById(key);
            if (element) {
                element.className = achievements[key] ? 'achievement unlocked' : 'achievement';
            }
        });
    }

    function pauseGame() {
        if (gameOver) return;
        paused = !paused;
        showNotification(paused ? 'PAUSED' : 'RESUMED');
    }

    function resetGame() {
        paddleX = (canvas.width - paddleWidth) / 2;
        currentPaddleWidth = paddleWidth;
        ballX = canvas.width / 2;
        ballY = canvas.height - 30;
        ballSpeed = 3;
        ballDX = ballSpeed;
        ballDY = -ballSpeed;
        rightPressed = leftPressed = aPressed = dPressed = false;
        score = 0;
        lives = 5;
        level = 1;
        win = false;
        gameOver = false;
        paused = false;
        gameStarted = true;
        
        // Reset power-ups and effects
        powerUps = [];
        particles = [];
        balls = [];
        comboCount = 1;
        comboTime = 0;
        screenShake = 0;
        paddleBoostTime = 0;
        multiballTime = 0;
        stickyPaddle = false;
        stickyTime = 0;
        ballStuck = false;
        
        levelStartTime = Date.now();
        setupBricks();
        updateScoreboard();
        stats.gamesPlayed++;
        initAudio();
    }

    function setupBricks() {
        brickRowCount = Math.min(brickRowCountBase + Math.floor(level / 2), 8);
        bricks = [];
        for (let c = 0; c < brickColCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                // Special brick types
                let brickType = 1;
                if (level > 3 && Math.random() < 0.1) brickType = 2; // Multi-hit
                if (level > 5 && Math.random() < 0.05) brickType = 3; // Unbreakable
                
                bricks[c][r] = { 
                    x: 0, 
                    y: 0, 
                    status: brickType,
                    hits: brickType === 2 ? 2 : 1
                };
            }
        }
    }

    function drawBricks() {
        for (let c = 0; c < brickColCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                if (bricks[c][r].status > 0) {
                    let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                    let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                    bricks[c][r].x = brickX;
                    bricks[c][r].y = brickY;
                    
                    ctx.beginPath();
                    ctx.rect(brickX, brickY, brickWidth, brickHeight);
                    
                    // Enhanced brick colors based on type and row
                    if (bricks[c][r].status === 3) {
                        ctx.fillStyle = "#666"; // Unbreakable
                    } else if (bricks[c][r].status === 2) {
                        ctx.fillStyle = bricks[c][r].hits > 1 ? "#fa0" : "#f80"; // Multi-hit
                    } else {
                        const colors = ["#0ff", "#ff0", "#f00", "#0f0", "#00f", "#f0f", "#fff", "#fa0"];
                        ctx.fillStyle = colors[r % colors.length];
                    }
                    
                    ctx.fill();
                    ctx.strokeStyle = "#222";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add shine effect
                    ctx.fillStyle = "rgba(255,255,255,0.3)";
                    ctx.fillRect(brickX + 2, brickY + 2, brickWidth - 4, 4);
                    
                    ctx.closePath();
                }
            }
        }
    }

    function drawPaddle() {
        ctx.save();
        
        // Apply screen shake
        if (screenShake > 0) {
            ctx.translate(
                (Math.random() - 0.5) * screenShake,
                (Math.random() - 0.5) * screenShake
            );
            screenShake *= shakeDecay;
        }
        
        ctx.beginPath();
        ctx.rect(paddleX, canvas.height - paddleHeight - 10, currentPaddleWidth, paddleHeight);
        
        // Special paddle effects
        if (stickyPaddle && Date.now() < stickyTime) {
            ctx.fillStyle = "#f0f";
            ctx.shadowColor = "#f0f";
            ctx.shadowBlur = 10;
        } else if (Date.now() < paddleBoostTime) {
            ctx.fillStyle = "#0f0";
            ctx.shadowColor = "#0f0";
            ctx.shadowBlur = 8;
        } else {
            ctx.fillStyle = "#fff";
        }
        
        ctx.fill();
        ctx.strokeStyle = "#0ff";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.closePath();
        ctx.restore();
    }

    function drawBall() {
        // Main ball
        ctx.beginPath();
        ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#ff0";
        ctx.fill();
        ctx.strokeStyle = "#0ff";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Ball trail effect
        ctx.shadowColor = "#ff0";
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.closePath();
        
        // Additional balls (multiball)
        balls.forEach(ball => {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#f80";
            ctx.fill();
            ctx.strokeStyle = "#0ff";
            ctx.stroke();
            ctx.closePath();
        });
    }

    function updateScoreboard() {
        document.getElementById('score').textContent = "Score: " + score;
        document.getElementById('lives').textContent = "Lives: " + lives;
        document.getElementById('level').textContent = "Level: " + level;
        document.getElementById('combo').textContent = "Combo: x" + comboCount;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Background effects
        if (level > 1) {
            for(let i = 0; i < 20; i++) {
                ctx.fillStyle = `rgba(0,255,255,${Math.random() * 0.1})`;
                ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 1, 1);
            }
        }
        
        drawBricks();
        drawPaddle();
        drawBall();
        drawPowerUps();
        drawParticles();

        if (paused) {
            ctx.font = "24px 'Press Start 2P'";
            ctx.fillStyle = "#ff0";
            ctx.textAlign = "center";
            ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2);
        }

        if (gameOver) {
            ctx.font = "18px 'Press Start 2P'";
            ctx.fillStyle = "#ff0";
            ctx.textAlign = "center";
            ctx.fillText(win ? "YOU WIN!" : "GAME OVER", canvas.width / 2, 150);
            ctx.font = "10px 'Press Start 2P'";
            ctx.fillStyle = "#fff";
            ctx.fillText("Press R to Restart", canvas.width / 2, 180);
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, 200);
        }
    }

    function collisionDetection() {
        let bricksLeft = 0;
        let liveBalls = [{ x: ballX, y: ballY, dx: ballDX, dy: ballDY }].concat(balls);
        
        liveBalls.forEach((ball, ballIndex) => {
            for (let c = 0; c < brickColCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    let b = bricks[c][r];
                    if (b.status > 0) {
                        if (b.status < 3) bricksLeft++; // Don't count unbreakable bricks
                        
                        if (
                            ball.x > b.x &&
                            ball.x < b.x + brickWidth &&
                            ball.y > b.y &&
                            ball.y < b.y + brickHeight
                        ) {
                            if (ballIndex === 0) {
                                ballDY = -ballDY;
                            } else {
                                balls[ballIndex - 1].dy = -balls[ballIndex - 1].dy;
                            }
                            
                            if (b.status < 3) { // Not unbreakable
                                b.hits--;
                                if (b.hits <= 0) {
                                    b.status = 0;
                                    
                                    // Scoring with combo
                                    let points = 10 * comboCount;
                                    score += points;
                                    stats.bricksDestroyed++;
                                    
                                    // Combo system
                                    const now = Date.now();
                                    if (now - lastHitTime < 1000) {
                                        comboCount++;
                                    } else {
                                        comboCount = 1;
                                    }
                                    lastHitTime = now;
                                    comboTime = now;
                                    
                                    // Effects
                                    createParticles(b.x + brickWidth/2, b.y + brickHeight/2, 
                                                   ["#0ff", "#ff0", "#f00", "#0f0", "#00f"][r % 5], 6);
                                    createPowerUp(b.x + brickWidth/2, b.y + brickHeight);
                                    screenShake = 3;
                                    
                                    playSound('brick', 880 + (r * 100), 80);
                                    updateScoreboard();
                                    bricksLeft--;
                                    
                                    if (bricksLeft === 0) {
                                        levelComplete();
                                    }
                                } else {
                                    // Multi-hit brick damaged
                                    createParticles(b.x + brickWidth/2, b.y + brickHeight/2, "#fa0", 3);
                                    playSound('brick', 660, 60);
                                }
                            } else {
                                // Hit unbreakable brick
                                createParticles(b.x + brickWidth/2, b.y + brickHeight/2, "#666", 2);
                                playSound('brick', 220, 40);
                            }
                        }
                    }
                }
            }
        });
        
        // Combo decay
        if (Date.now() - comboTime > 2000) {
            comboCount = 1;
        }
    }
    
    function levelComplete() {
        const levelTime = Date.now() - levelStartTime;
        stats.levelsCompleted++;
        
        // Check for perfect level (no lives lost)
        if (lives === 5) {
            stats.perfectLevels++;
            if (!achievements.perfectLevel) {
                achievements.perfectLevel = true;
                showNotification('Perfect Level - No lives lost!', 3000);
            }
        }
        
        // Check for speed achievement
        if (levelTime < 30000 && !achievements.speedRunner) {
            achievements.speedRunner = true;
            showNotification('Speed Runner - Lightning fast!', 3000);
        }
        
        if (level < maxLevel) {
            level++;
            lives++;
            ballSpeed += 0.3;
            ballDX = (ballDX > 0 ? 1 : -1) * ballSpeed;
            ballDY = (ballDY > 0 ? 1 : -1) * ballSpeed;
            setupBricks();
            ballX = canvas.width / 2;
            ballY = canvas.height - 30;
            paddleX = (canvas.width - paddleWidth) / 2;
            levelStartTime = Date.now();
            playSound('levelup');
            updateScoreboard();
            checkAchievements();
            showNotification(`Level ${level}!`, 2000);
        } else {
            win = true;
            gameOver = true;
            playSound('levelup');
            showNotification('Congratulations! Game Complete!', 5000);
        }
    }

    function update() {
        if (gameOver || paused) return;

        // Update power-up timers
        if (Date.now() > paddleBoostTime) {
            currentPaddleWidth = paddleWidth;
        }
        if (Date.now() > stickyTime) {
            stickyPaddle = false;
        }
        if (Date.now() > multiballTime) {
            balls = [];
        }

        // Move paddle
        if ((rightPressed || dPressed) && paddleX < canvas.width - currentPaddleWidth) {
            paddleX += paddleSpeed;
        }
        if ((leftPressed || aPressed) && paddleX > 0) {
            paddleX -= paddleSpeed;
        }

        // Handle sticky paddle
        if (ballStuck && stickyPaddle) {
            ballX = paddleX + currentPaddleWidth / 2;
            return;
        }

        // Move main ball
        ballX += ballDX;
        ballY += ballDY;
        
        // Move additional balls
        balls.forEach(ball => {
            ball.x += ball.dx;
            ball.y += ball.dy;
        });

        // Wall collision for main ball
        if (ballX + ballRadius > canvas.width || ballX - ballRadius < 0) {
            ballDX = -ballDX;
            playSound('brick', 440, 40);
        }
        if (ballY - ballRadius < 0) {
            ballDY = -ballDY;
            playSound('brick', 440, 40);
        }
        
        // Wall collision for additional balls
        balls.forEach(ball => {
            if (ball.x + ballRadius > canvas.width || ball.x - ballRadius < 0) {
                ball.dx = -ball.dx;
            }
            if (ball.y - ballRadius < 0) {
                ball.dy = -ball.dy;
            }
        });

        // Paddle collision for main ball
        if (
            ballY + ballRadius > canvas.height - paddleHeight - 10 &&
            ballX > paddleX &&
            ballX < paddleX + currentPaddleWidth
        ) {
            if (stickyPaddle && !ballStuck) {
                ballStuck = true;
                ballDY = 0;
                ballDX = 0;
            } else {
                ballDY = -Math.abs(ballDY);
                let hitPos = (ballX - (paddleX + currentPaddleWidth / 2)) / (currentPaddleWidth / 2);
                ballDX = ballSpeed * hitPos * 0.8;
                playSound('paddle', 660, 60);
                screenShake = 2;
            }
        }
        
        // Paddle collision for additional balls
        balls = balls.filter(ball => {
            if (
                ball.y + ballRadius > canvas.height - paddleHeight - 10 &&
                ball.x > paddleX &&
                ball.x < paddleX + currentPaddleWidth
            ) {
                ball.dy = -Math.abs(ball.dy);
                let hitPos = (ball.x - (paddleX + currentPaddleWidth / 2)) / (currentPaddleWidth / 2);
                ball.dx = ballSpeed * hitPos * 0.8;
                playSound('paddle', 660, 60);
            }
            
            // Remove balls that fall off screen
            if (ball.y + ballRadius > canvas.height) {
                return false;
            }
            return true;
        });

        // Bottom collision (lose life) for main ball
        if (ballY + ballRadius > canvas.height) {
            lives--;
            playSound('brick', 220, 300);
            updateScoreboard();
            
            if (!lives) {
                gameOver = true;
                if (score > stats.bestScore) {
                    stats.bestScore = score;
                    showNotification('New High Score!', 3000);
                }
                saveData();
            } else {
                ballX = canvas.width / 2;
                ballY = canvas.height - 30;
                ballDX = ballSpeed;
                ballDY = -ballSpeed;
                paddleX = (canvas.width - paddleWidth) / 2;
                ballStuck = false;
                comboCount = 1;
            }
        }

        updatePowerUps();
        updateParticles();
        collisionDetection();
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    document.addEventListener("keydown", function(e) {
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", " ", "a", "A", "d", "D"].includes(e.key)) {
            e.preventDefault();
        }
        
        // Only prevent R key default when game is over (for restart)
        if (e.key === "r" || e.key === "R") {
            e.preventDefault();
        }
        
        if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
        if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
        if (e.key === "a" || e.key === "A") aPressed = true;
        if (e.key === "d" || e.key === "D") dPressed = true;
        
        if (e.key === " " || e.key === "Spacebar") {
            if (ballStuck) {
                ballStuck = false;
                ballDY = -ballSpeed;
                ballDX = (Math.random() - 0.5) * ballSpeed;
            } else {
                pauseGame();
            }
        }
        
        if (e.key === "r" || e.key === "R") {
            resetGame();
        }
    });

    document.addEventListener("keyup", function(e) {
        if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
        if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
        if (e.key === "a" || e.key === "A") aPressed = false;
        if (e.key === "d" || e.key === "D") dPressed = false;
    });

    // Mouse/touch support
    canvas.addEventListener('mousemove', function(e) {
        if (gameOver || paused) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        paddleX = mouseX - currentPaddleWidth / 2;
        paddleX = Math.max(0, Math.min(paddleX, canvas.width - currentPaddleWidth));
    });

    canvas.addEventListener('click', function(e) {
        if (ballStuck) {
            ballStuck = false;
            ballDY = -ballSpeed;
            ballDX = (Math.random() - 0.5) * ballSpeed;
        }
    });

    // Initialize game
    loadData();
    resetGame();
    loop();
    </script>
</body>
</html>