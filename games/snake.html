<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <style>
        body {
            background: #222;
            color: #fff;
            font-family: 'Press Start 2P', monospace, cursive;
            min-height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #181818;
            border-radius: 16px;
            box-shadow: 0 0 32px #0ff8, 0 0 8px #000a;
            padding: 32px 32px 16px 32px;
            margin-top: 40px;
        }
        .scoreboard {
            display: flex;
            gap: 32px;
            justify-content: center;
            align-items: center;
            margin-bottom: 12px;
            font-size: 14px;
            font-family: 'Press Start 2P', monospace, cursive;
            background: #111;
            border: 2px solid #0ff;
            border-radius: 8px;
            padding: 8px 24px;
            color: #fff;
            box-shadow: 0 0 8px #0ff4;
        }
        .level-progress-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 10px;
            color: #0ff;
            background: #222;
            border: 1px solid #0ff;
            border-radius: 6px;
            padding: 6px 16px;
        }
        .progress-label {
            font-size: 10px;
            color: #fff;
        }
        .progress-bar-bg {
            width: 120px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background: #0ff;
            width: 0%;
            transition: width 0.3s ease, background-color 0.3s ease;
            border-radius: 4px;
        }
        .progress-text {
            font-size: 10px;
            color: #fff;
            min-width: 30px;
        }
        .lives-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 10px;
            color: #fff;
            background: #222;
            border: 1px solid #ff0;
            border-radius: 6px;
            padding: 6px 16px;
        }
        .lives-label {
            font-size: 10px;
            color: #fff;
        }
        .heart-icon {
            color: #ff0000;
            font-size: 12px;
            margin: 0 2px;
            transition: color 0.3s ease;
        }
        .heart-icon.lost {
            color: #444;
        }
        .respawn-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: #fff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            display: none;
            z-index: 20;
        }
        .stats-bar {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-bottom: 8px;
            font-size: 10px;
            background: #222;
            border: 1px solid #0ff;
            border-radius: 6px;
            padding: 6px 16px;
            color: #0ff;
        }
        .game-area {
            position: relative;
            display: inline-block;
        }
        .power-up-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 0, 0.9);
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            display: none;
            z-index: 10;
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #0ff, #00aa88);
            color: #000;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
        }
        .notification.show {
            transform: translateX(0);
        }
        .achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #ff0, #ffa500);
            color: #000;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            transition: transform 0.3s ease;
            z-index: 1001;
            box-shadow: 0 8px 24px rgba(255, 255, 0, 0.4);
        }
        .achievement-popup.show {
            transform: translate(-50%, -50%) scale(1);
        }
        .controls-info {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 8px;
            font-size: 10px;
            color: #888;
        }
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: #fff;
            font-size: 16px;
            z-index: 5;
        }
        .game-mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 10px;
        }
        .mode-btn {
            background: #333;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mode-btn:hover, .mode-btn.active {
            background: #0ff;
            color: #000;
        }
        #gameCanvas {
            background: #111;
            border: 6px solid #0ff;
            border-radius: 8px;
            image-rendering: pixelated;
            box-shadow: 0 0 24px #0ff8;
            margin-bottom: 16px;
            display: block;
        }
        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px #0ff, 0 0 8px #0ff8;
            letter-spacing: 2px;
        }
        .instructions {
            background: #222;
            border: 2px solid #0ff;
            border-radius: 8px;
            padding: 10px 18px;
            margin-top: 10px;
            font-size: 12px;
            color: #fff;
            text-align: center;
            box-shadow: 0 0 8px #0ff4;
        }
        .instructions span {
            color: #0ff;
        }
        a.menu-link {
            color: #0ff;
            display: block;
            margin: 12px 0;
            text-align: center;
            text-decoration: none;
        }
        a.menu-link:hover {
            text-decoration: underline;
        }
        footer {
            margin-top: 24px;
            color: #0ff;
            font-size: 10px;
            text-align: center;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Snake</h1>
        <div class="stats-bar">
            <span id="games-played">Games: 0</span>
            <span id="high-score">Best: 0</span>
            <span id="longest-snake">Longest: 3</span>
        </div>
        <div class="game-mode-selector">
            <button class="mode-btn active" data-mode="classic">Classic</button>
            <button class="mode-btn" data-mode="survival">Survival</button>
            <button class="mode-btn" data-mode="timeattack">Time Attack</button>
        </div>
        <div class="scoreboard">
            <span id="score">Score: 0</span>
            <span id="level">Level: 0</span>
            <span id="timer" style="display: none;">Time: 120s</span>
        </div>
        <div class="level-progress-container" id="level-progress-container">
            <div class="progress-label">Next Level Progress:</div>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill" id="progress-bar-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">0/10</div>
        </div>
        <div class="lives-container" id="lives-container">
            <div class="lives-label">Lives:</div>
            <div class="hearts-display" id="hearts-display">
                <span class="heart-icon">♥</span>
                <span class="heart-icon">♥</span>
                <span class="heart-icon">♥</span>
            </div>
        </div>
        <div class="game-area">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            <div class="power-up-indicator" id="power-up-indicator"></div>
            <div class="respawn-indicator" id="respawn-indicator">Life Lost! Respawning...</div>
            <div class="pause-overlay" id="pause-overlay">
                <div>PAUSED</div>
                <div style="font-size: 10px; margin-top: 10px;">Press SPACE to continue</div>
            </div>
        </div>
        <div class="instructions">
            <p>
                Use <span>Arrow Keys</span> or <span>WASD</span> to move<br>
                Collect items to grow. <span>Space</span> to pause<br>
                Power-ups appear randomly!<br>
                <b>Press <span>R</span> to restart</b>
            </p>
        </div>
        <div class="controls-info">
            <span>Touch/Swipe supported</span>
            <span>Multiple game modes</span>
        </div>
        <a class="menu-link" href="../public/arcade.html">&#8592; Back to Menu</a>
    </div>
    <div class="notification" id="notification"></div>
        <div class="achievement-popup" id="achievement-popup"></div>
    <footer>
        <p>&copy; 2025 Your Name</p>
    </footer>
    <script>
    // Prevent arrow keys from scrolling the page
    window.addEventListener("keydown", function(e) {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
            e.preventDefault();
        }
    }, { passive: false });

    window.onload = function() {
        // Enhanced sound system
        function playSound(frequency = 440, duration = 100, type = "square") {
            if (!window.AudioContext) return;
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = type;
            osc.frequency.value = frequency;
            gain.gain.setValueAtTime(0.1, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration / 1000);
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + duration / 1000);
        }

        function playPowerUpSound() {
            playSound(600, 200, "sine");
            setTimeout(() => playSound(800, 200, "sine"), 100);
        }

        function playAchievementSound() {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => playSound(440 + i * 220, 300, "sine"), i * 100);
            }
        }

        // Game elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const timerEl = document.getElementById('timer');
        const gamesPlayedEl = document.getElementById('games-played');
        const highScoreEl = document.getElementById('high-score');
        const longestSnakeEl = document.getElementById('longest-snake');
        const powerUpIndicator = document.getElementById('power-up-indicator');
        const pauseOverlay = document.getElementById('pause-overlay');

        // Game constants
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

        // Game variables
        let snake, direction, nextDirection, gameMode, gameOver, win, isPaused;
        let score, level, speed, timeLeft, gameStartTime;
        let particles = [];
        let powerUps = [];
        let coins = [];
        let activePowerUp = null;
        let powerUpTimer = 0;
        let combo = 0;
        let screenShake = 0;
        let backgroundOffset = 0;
        let lives = 3;
        let maxLives = 5;
        let invulnerabilityTimer = 0;
        let respawnTimer = 0;

        // Input handling
        let inputQueue = [];
        let touchStartX = 0;
        let touchStartY = 0;

        // Statistics
        let stats = {
            gamesPlayed: 0,
            highScore: 0,
            longestSnake: 3,
            totalCoins: 0,
            powerUpsCollected: 0,
            totalPlayTime: 0
        };

        // Achievements
        let achievements = {
            firstBite: false,
            speedDemon: false,
            masterSnake: false,
            snakeLegend: false,
            snakeGod: false,
            efficiencyExpert: false,
            powerCollector: false,
            survivor: false,
            perfectRun: false,
            comboMaster: false
        };

        // Game modes
        const gameModes = {
            classic: { name: "Classic", timeLimit: null, hasObstacles: false },
            survival: { name: "Survival", timeLimit: null, hasObstacles: true },
            timeattack: { name: "Time Attack", timeLimit: 120, hasObstacles: false }
        };

        // Load saved data
        function loadData() {
            const savedStats = localStorage.getItem('snakeStats');
            const savedAchievements = localStorage.getItem('snakeAchievements');
            
            if (savedStats) {
                stats = { ...stats, ...JSON.parse(savedStats) };
            }
            if (savedAchievements) {
                achievements = { ...achievements, ...JSON.parse(savedAchievements) };
            }
            updateStatsDisplay();
        }

        // Save data
        function saveData() {
            localStorage.setItem('snakeStats', JSON.stringify(stats));
            localStorage.setItem('snakeAchievements', JSON.stringify(achievements));
        }

        // Particle system
        class Particle {
            constructor(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1;
            }
        }

        // Power-up system
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.pulseTimer = 0;
                this.collected = false;
            }

            update() {
                this.pulseTimer += 0.1;
            }

            draw() {
                const pulse = Math.sin(this.pulseTimer) * 0.3 + 0.7;
                ctx.globalAlpha = pulse;
                
                const centerX = this.x * gridSize + gridSize / 2;
                const centerY = this.y * gridSize + gridSize / 2;
                
                switch (this.type) {
                    case 'speed':
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(centerX - 8, centerY - 8, 16, 16);
                        break;
                    case 'slow':
                        ctx.fillStyle = '#0000ff';
                        ctx.fillRect(centerX - 8, centerY - 8, 16, 16);
                        break;
                    case 'multiplier':
                        ctx.fillStyle = '#ff00ff';
                        ctx.fillRect(centerX - 8, centerY - 8, 16, 16);
                        break;
                    case 'shrink':
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(centerX - 8, centerY - 8, 16, 16);
                        break;
                    case 'golden':
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(centerX - 10, centerY - 10, 20, 20);
                        break;
                }
                ctx.globalAlpha = 1;
            }

            checkCollision(headX, headY) {
                return this.x === headX && this.y === headY;
            }
        }

        // Coin system
        class Coin {
            constructor(x, y, type = 'normal') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.animTimer = 0;
                this.value = type === 'golden' ? 3 : 1;
            }

            update() {
                this.animTimer += 0.1;
            }

            draw() {
                const centerX = this.x * gridSize + gridSize / 2;
                const centerY = this.y * gridSize + gridSize / 2;
                const pulse = Math.sin(this.animTimer) * 0.2 + 0.8;
                
                // Optimized rendering - reduced shadow blur operations
                if (this.type === 'golden') {
                    ctx.fillStyle = "#ffd700";
                    // Only use shadow for golden coins and reduce blur
                    ctx.shadowColor = "#ffd700";
                    ctx.shadowBlur = 3;
                } else {
                    ctx.fillStyle = "#ff0";
                    // Remove shadow for regular coins to improve performance
                    ctx.shadowBlur = 0;
                }
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, (gridSize / 2.3) * pulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                if (this.type === 'golden') {
                    ctx.strokeStyle = "#ffa500";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, (gridSize / 2.3) * pulse, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            checkCollision(headX, headY) {
                return this.x === headX && this.y === headY;
            }
        }

        // Create particles
        function createParticles(x, y, color, count = 8) {
            // Limit total particles to prevent performance degradation
            if (particles.length > 40) {
                particles.splice(0, particles.length - 25);
            }
            
            // Reduce particle count for better performance
            const particleCount = Math.min(count, 6);
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                // Reduced particle lifetime for better cleanup
                particles.push(new Particle(x, y, vx, vy, color, 20 + Math.random() * 15));
            }
        }

        // Spawn power-up
        function spawnPowerUp() {
            if (powerUps.length === 0 && Math.random() < 0.005) {
                const types = ['speed', 'slow', 'multiplier', 'shrink', 'golden'];
                const type = types[Math.floor(Math.random() * types.length)];
                let x, y;
                do {
                    x = Math.floor(Math.random() * tileCount);
                    y = Math.floor(Math.random() * tileCount);
                } while (
                    snake.some(seg => seg.x === x && seg.y === y) ||
                    coins.some(coin => coin.x === x && coin.y === y)
                );
                powerUps.push(new PowerUp(x, y, type));
            }
        }

        // Apply power-up
        function applyPowerUp(type) {
            activePowerUp = type;
            powerUpTimer = 300; // 5 seconds at 60fps
            stats.powerUpsCollected++;
            
            let message = '';
            switch (type) {
                case 'speed':
                    speed = Math.max(20, speed - 40);
                    message = 'Speed Boost!';
                    break;
                case 'slow':
                    speed += 40;
                    message = 'Slow Motion!';
                    break;
                case 'multiplier':
                    message = '2x Score!';
                    break;
                case 'shrink':
                    if (snake.length > 3) {
                        snake.splice(-2);
                        message = 'Snake Shrunk!';
                    }
                    break;
                case 'golden':
                    score += 3;
                    // Recalculate level after golden power-up score boost
                    const newLevel = Math.floor(score / 10);
                    if (newLevel > level && level < 20) {
                        level = newLevel;
                        speed = Math.max(30, 120 - level * 4);
                        showNotification(`Golden Coin! +3 → Level ${level}!`);
                        playSound(800, 300, "sine");
                    } else {
                        message = 'Golden Coin! +3';
                    }
                    updateScoreboard(); // Update scoreboard when golden power-up adds score
                    break;
            }
            
            showNotification(message);
            updatePowerUpIndicator();
            playPowerUpSound();
            
            if (stats.powerUpsCollected >= 20 && !achievements.powerCollector) {
                unlockAchievement('powerCollector', 'Power Collector!', 'Collected 20 power-ups');
            }
        }

        // Update power-up indicator
        function updatePowerUpIndicator() {
            if (activePowerUp && powerUpTimer > 0) {
                let text = '';
                switch (activePowerUp) {
                    case 'speed': text = `Speed: ${Math.ceil(powerUpTimer / 60)}s`; break;
                    case 'slow': text = `Slow: ${Math.ceil(powerUpTimer / 60)}s`; break;
                    case 'multiplier': text = `2x Score: ${Math.ceil(powerUpTimer / 60)}s`; break;
                }
                powerUpIndicator.textContent = text;
                powerUpIndicator.style.display = 'block';
            } else {
                powerUpIndicator.style.display = 'none';
            }
        }

        // Notifications
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        // Achievement system
        function unlockAchievement(key, title, description) {
            if (!achievements[key]) {
                achievements[key] = true;
                showAchievement(title, description);
                playAchievementSound();
                saveData();
            }
        }

        function showAchievement(title, description) {
            const popup = document.getElementById('achievement-popup');
            popup.innerHTML = `
                <div style="font-size: 16px; margin-bottom: 8px;">🏆 Achievement Unlocked!</div>
                <div style="font-size: 14px; margin-bottom: 4px;">${title}</div>
                <div style="font-size: 10px;">${description}</div>
            `;
            popup.classList.add('show');
            setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);
        }

        // Check achievements
        function checkAchievements() {
            if (score >= 1 && !achievements.firstBite) {
                unlockAchievement('firstBite', 'First Bite!', 'Collected your first coin');
            }
            
            if (level >= 7 && !achievements.speedDemon) {
                unlockAchievement('speedDemon', 'Speed Demon!', 'Reached level 7');
            }
            
            if (level >= 15 && !achievements.masterSnake) {
                unlockAchievement('masterSnake', 'Master Snake!', 'Reached level 15');
            }
            
            if (level >= 20 && !achievements.snakeLegend) {
                unlockAchievement('snakeLegend', 'Snake Legend!', 'Reached level 20');
            }
            
            if (level >= 25 && !achievements.snakeGod) {
                unlockAchievement('snakeGod', 'Snake God!', 'Impossible level achieved!');
            }
            
            if (snake.length >= 20 && !achievements.efficiencyExpert) {
                unlockAchievement('efficiencyExpert', 'Efficiency Expert!', 'Grew to 20+ segments');
            }
            
            if (combo >= 5 && !achievements.comboMaster) {
                unlockAchievement('comboMaster', 'Combo Master!', 'Achieved 5x combo');
            }
            
            const playTime = (Date.now() - gameStartTime) / 1000;
            if (playTime >= 600 && !achievements.survivor) {
                unlockAchievement('survivor', 'Survivor!', 'Played for 10+ minutes');
            }
            
            // Perfect run achievement - complete game without losing any lives
            if (win && lives === 3 && !achievements.perfectRun) {
                unlockAchievement('perfectRun', 'Flawless Victory!', 'Won without losing any lives');
            }
        }

        function ensureCoinExists() {
            // Make sure there's always exactly one coin on the field
            if (coins.length === 0) {
                placeCoin();
            } else if (coins.length > 1) {
                // Remove extra coins, keep only the first one
                coins.splice(1);
            }
        }

        function placeCoin() {
            // Ensure we don't place multiple coins
            if (coins.length >= 1) {
                return; // Already have a coin, don't place another
            }
            
            let x, y;
            let attempts = 0;
            do {
                x = Math.floor(Math.random() * tileCount);
                y = Math.floor(Math.random() * tileCount);
                attempts++;
                // Prevent infinite loop if board is full
                if (attempts > 100) break;
            } while (
                snake.some(seg => seg.x === x && seg.y === y) ||
                powerUps.some(powerUp => powerUp.x === x && powerUp.y === y) ||
                coins.some(coin => coin.x === x && coin.y === y)
            );
            
            const type = Math.random() < 0.1 ? 'golden' : 'normal';
            coins.push(new Coin(x, y, type));
        }

        function resetGame() {
            snake = [
                { x: 8, y: 10 },
                { x: 7, y: 10 },
                { x: 6, y: 10 }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            inputQueue = [];
            
            coins = [];
            placeCoin();
            
            score = 0;
            level = 0;
            speed = gameMode === 'timeattack' ? 80 : 120;
            gameOver = false;
            win = false;
            isPaused = false;
            combo = 0;
            screenShake = 0;
            lives = 3;
            invulnerabilityTimer = 0;
            respawnTimer = 0;
            
            // Reset power-ups
            powerUps = [];
            activePowerUp = null;
            powerUpTimer = 0;
            updatePowerUpIndicator();
            
            // Reset timer for time attack mode
            if (gameMode === 'timeattack') {
                timeLeft = 120;
                timerEl.style.display = 'inline';
            } else {
                timerEl.style.display = 'none';
            }
            
            gameStartTime = Date.now();
            updateScoreboard();
            updateLivesDisplay();
            
            // Hide respawn indicator
            document.getElementById('respawn-indicator').style.display = 'none';
            
            // Force an immediate display update
            setTimeout(() => {
                updateScoreboard();
            }, 10);
        }

        function updateStatsDisplay() {
            gamesPlayedEl.textContent = `Games: ${stats.gamesPlayed}`;
            highScoreEl.textContent = `Best: ${stats.highScore}`;
            longestSnakeEl.textContent = `Longest: ${stats.longestSnake}`;
        }

        function updateLivesDisplay() {
            const heartsDisplay = document.getElementById('hearts-display');
            heartsDisplay.innerHTML = '';
            
            for (let i = 0; i < maxLives; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart-icon';
                heart.textContent = '♥';
                
                if (i >= lives) {
                    heart.classList.add('lost');
                }
                
                heartsDisplay.appendChild(heart);
            }
        }

        function grantBonusLife() {
            if (lives < maxLives) {
                lives++;
                updateLivesDisplay();
                showNotification('Bonus Life! +1 ♥');
                playSound(1000, 300, "sine");
                
                // Special particle effect for bonus life
                createParticles(canvas.width / 2, canvas.height / 2, "#ff0000", 15);
                
                if (!achievements.perfectRun && lives === maxLives) {
                    unlockAchievement('perfectRun', 'Life Master!', 'Reached maximum lives');
                }
            }
        }

        function drawBackground() {
            // Animated grid background
            backgroundOffset += 0.5;
            if (backgroundOffset >= gridSize) backgroundOffset = 0;
            
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            for (let x = -backgroundOffset; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -backgroundOffset; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawSnake() {
            // Dynamic colors based on level milestones
            let bodyColor1, bodyColor2, headColor1, headColor2;
            
            if (level >= 20) {
                // Level 20: Gold/Divine
                bodyColor1 = "#ffd700"; bodyColor2 = "#ff8c00";
                headColor1 = "#ffff00"; headColor2 = "#ffa500";
            } else if (level >= 15) {
                // Level 15+: Purple/Legendary
                bodyColor1 = "#8a2be2"; bodyColor2 = "#4b0082";
                headColor1 = "#9370db"; headColor2 = "#6a5acd";
            } else if (level >= 10) {
                // Level 10+: Red/Advanced
                bodyColor1 = "#ff4500"; bodyColor2 = "#dc143c";
                headColor1 = "#ff6347"; headColor2 = "#ff2500";
            } else if (level >= 5) {
                // Level 5+: Green/Intermediate
                bodyColor1 = "#32cd32"; bodyColor2 = "#228b22";
                headColor1 = "#00ff32"; headColor2 = "#00cc28";
            } else {
                // Level 0-4: Cyan/Beginner (original)
                bodyColor1 = "#0ff"; bodyColor2 = "#0aa";
                headColor1 = "#00fa9a"; headColor2 = "#00aa55";
            }
            
            // Invulnerability flashing effect
            let alpha = 1;
            if (invulnerabilityTimer > 0) {
                alpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.02);
            }
            ctx.globalAlpha = alpha;
            
            // Draw snake body with gradient
            for (let i = 1; i < snake.length; i++) {
                const segmentAlpha = alpha * (1 - (i / snake.length) * 0.3);
                ctx.globalAlpha = segmentAlpha;
                
                const gradient = ctx.createRadialGradient(
                    snake[i].x * gridSize + gridSize / 2,
                    snake[i].y * gridSize + gridSize / 2,
                    0,
                    snake[i].x * gridSize + gridSize / 2,
                    snake[i].y * gridSize + gridSize / 2,
                    gridSize / 2
                );
                gradient.addColorStop(0, bodyColor1);
                gradient.addColorStop(1, bodyColor2);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(
                    snake[i].x * gridSize + gridSize / 2,
                    snake[i].y * gridSize + gridSize / 2,
                    gridSize / 2.2,
                    0, Math.PI * 2
                );
                ctx.fill();
            }

            // Draw snake head with glow effect
            ctx.globalAlpha = alpha;
            const head = snake[0];
            ctx.shadowColor = headColor1;
            ctx.shadowBlur = level >= 15 ? 20 : 15; // Enhanced glow for higher levels
            
            const headGradient = ctx.createRadialGradient(
                head.x * gridSize + gridSize / 2,
                head.y * gridSize + gridSize / 2,
                0,
                head.x * gridSize + gridSize / 2,
                head.y * gridSize + gridSize / 2,
                gridSize / 2
            );
            headGradient.addColorStop(0, headColor1);
            headGradient.addColorStop(1, headColor2);
            
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(
                head.x * gridSize + gridSize / 2,
                head.y * gridSize + gridSize / 2,
                gridSize / 2,
                0, Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw eyes
            ctx.fillStyle = "#222";
            const eyeOffsetX = direction.x === 0 ? -4 : direction.x * 5;
            const eyeOffsetY = direction.y === 0 ? -4 : direction.y * 5;
            ctx.beginPath();
            ctx.arc(
                head.x * gridSize + gridSize / 2 + eyeOffsetX,
                head.y * gridSize + gridSize / 2 + eyeOffsetY,
                2, 0, Math.PI * 2
            );
            ctx.arc(
                head.x * gridSize + gridSize / 2 - eyeOffsetX,
                head.y * gridSize + gridSize / 2 - eyeOffsetY,
                2, 0, Math.PI * 2
            );
            ctx.fill();
            
            ctx.globalAlpha = 1;
        }

        function draw() {
            ctx.save();
            
            // Screen shake effect
            if (screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake,
                    (Math.random() - 0.5) * screenShake
                );
                screenShake *= 0.9;
                if (screenShake < 0.1) screenShake = 0;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();

            // Draw coins
            coins.forEach(coin => coin.draw());

            // Draw power-ups
            powerUps.forEach(powerUp => powerUp.draw());

            drawSnake();

            // Draw particles
            particles.forEach(particle => particle.draw());

            // Draw combo indicator
            if (combo > 1) {
                ctx.font = "14px 'Press Start 2P', monospace";
                ctx.fillStyle = "#ff0";
                ctx.fillText(`${combo}x COMBO!`, 10, 30);
            }

            // Draw game over/win screen
            if (gameOver || win) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.font = "20px 'Press Start 2P', monospace";
                ctx.fillStyle = "#fff";
                
                if (win) {
                    ctx.fillText("YOU WIN!", 90, 180);
                } else {
                    ctx.fillText("GAME OVER", 60, 180);
                }
                
                ctx.font = "12px 'Press Start 2P', monospace";
                ctx.fillStyle = "#0ff";
                ctx.fillText(`Score: ${score}`, 130, 210);
                ctx.fillText(`Level: ${level}`, 130, 230);
                
                ctx.font = "10px 'Press Start 2P', monospace";
                ctx.fillStyle = "#fff";
                ctx.fillText("Press R to Restart", 80, 260);
            }
            
            ctx.restore();
        }

        function updateScoreboard() {
            scoreEl.textContent = `Score: ${score}`;
            levelEl.textContent = `Level: ${level}`;
            if (gameMode === 'timeattack') {
                timerEl.textContent = `Time: ${timeLeft}s`;
            }
            
            // Update progress bar
            updateProgressBar();
            
            // Force a refresh of the display
            scoreEl.style.display = 'inline';
            levelEl.style.display = 'inline';
        }

        function updateProgressBar() {
            const progressContainer = document.getElementById('level-progress-container');
            const progressFill = document.getElementById('progress-bar-fill');
            const progressText = document.getElementById('progress-text');
            
            if (level >= 20) {
                // Hide progress bar when max level reached
                progressContainer.style.display = 'none';
                return;
            } else {
                progressContainer.style.display = 'flex';
            }
            
            const currentLevelScore = score % 10;
            const progressToNext = currentLevelScore / 10;
            const pointsNeeded = 10 - currentLevelScore;
            
            // Update progress bar width
            progressFill.style.width = `${progressToNext * 100}%`;
            
            // Update progress bar color based on level
            let progressColor = "#0ff";
            if (level >= 15) progressColor = "#8a2be2";
            else if (level >= 10) progressColor = "#ff4500";
            else if (level >= 5) progressColor = "#32cd32";
            
            progressFill.style.backgroundColor = progressColor;
            
            // Update progress text
            progressText.textContent = `${currentLevelScore}/10`;
            
            // Update label for next level
            const progressLabel = progressContainer.querySelector('.progress-label');
            if (level < 19) {
                progressLabel.textContent = `Next Level (${level + 1}):`;
            } else {
                progressLabel.textContent = `Final Level (20):`;
            }
        }

        function gameLoop() {
            if (gameOver || win || isPaused) {
                draw();
                if (!gameOver && !win && isPaused) {
                    requestAnimationFrame(gameLoop);
                }
                return;
            }
            
            // Use requestAnimationFrame for smoother performance
            setTimeout(() => {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }, speed);
        }

        function update() {
            // Update particles
            particles = particles.filter(particle => {
                particle.update();
                return particle.life > 0;
            });

            // Update timers
            if (invulnerabilityTimer > 0) invulnerabilityTimer--;
            if (respawnTimer > 0) {
                respawnTimer--;
                if (respawnTimer === 0) {
                    document.getElementById('respawn-indicator').style.display = 'none';
                }
            }

            // Update coins
            coins.forEach(coin => coin.update());
            
            // Ensure there's always exactly one coin
            ensureCoinExists();

            // Update power-ups
            powerUps.forEach(powerUp => powerUp.update());
            spawnPowerUp();
            
            // Update power-up timer
            if (powerUpTimer > 0) {
                powerUpTimer--;
                if (powerUpTimer === 0) {
                    if (activePowerUp === 'speed' || activePowerUp === 'slow') {
                        speed = gameMode === 'timeattack' ? 80 : Math.max(30, 120 - level * 4);
                    }
                    activePowerUp = null;
                }
                updatePowerUpIndicator();
            }

            // Handle input queue
            if (inputQueue.length > 0) {
                const nextInput = inputQueue.shift();
                if (isValidDirection(nextInput)) {
                    nextDirection = nextInput;
                }
            }

            // Time attack mode timer
            if (gameMode === 'timeattack') {
                timeLeft--;
                if (timeLeft <= 0) {
                    gameOver = true;
                    finalizeGame();
                    return;
                }
                updateScoreboard();
            }

            move();
        }

        function isValidDirection(newDirection) {
            return !(direction.x === -newDirection.x && direction.y === -newDirection.y);
        }

        function respawnSnake() {
            // Reset snake to starting position
            snake = [
                { x: 8, y: 10 },
                { x: 7, y: 10 },
                { x: 6, y: 10 }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            
            // Grant invulnerability
            invulnerabilityTimer = 180; // 3 seconds at 60fps
            respawnTimer = 120; // Show message for 2 seconds
            
            // Visual effects
            screenShake = 5;
            createParticles(
                snake[0].x * gridSize + gridSize / 2,
                snake[0].y * gridSize + gridSize / 2,
                "#ff0000", 10
            );
            
            // Show respawn message
            document.getElementById('respawn-indicator').style.display = 'block';
            
            // Play respawn sound
            playSound(300, 200, "sine");
            
            showNotification(`Lives remaining: ${lives}`);
        }

        function move() {
            direction = nextDirection;

            // Calculate new head position
            let newX, newY;
            if (gameMode === 'survival') {
                // Survival mode: solid walls
                newX = snake[0].x + direction.x;
                newY = snake[0].y + direction.y;
                
                if (newX < 0 || newX >= tileCount || newY < 0 || newY >= tileCount) {
                    gameOver = true;
                    finalizeGame();
                    return;
                }
            } else {
                // Classic/Time Attack: wrap around
                newX = (snake[0].x + direction.x + tileCount) % tileCount;
                newY = (snake[0].y + direction.y + tileCount) % tileCount;
            }
            
            const newHead = { x: newX, y: newY };

            // Check self collision
            if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
                if (invulnerabilityTimer > 0) {
                    // Still invulnerable, ignore collision
                    return;
                }
                
                lives--;
                updateLivesDisplay();
                
                if (lives <= 0) {
                    gameOver = true;
                    createParticles(
                        newHead.x * gridSize + gridSize / 2,
                        newHead.y * gridSize + gridSize / 2,
                        "#ff0000", 15
                    );
                    screenShake = 10;
                    playSound(150, 500, "sawtooth");
                    finalizeGame();
                    return;
                } else {
                    // Respawn with invulnerability
                    respawnSnake();
                    return;
                }
            }

            snake.unshift(newHead);

            // Check coin collision
            let coinCollected = false;
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                if (coin.checkCollision(newHead.x, newHead.y)) {
                    coinCollected = true;
                    let points = coin.value;
                    
                    if (activePowerUp === 'multiplier') {
                        points *= 2;
                    }
                    
                    score += points;
                    combo++;
                    stats.totalCoins++;
                    
                    // Calculate current level based on score
                    const newLevel = Math.floor(score / 10);
                    
                    // Remove the collected coin
                    coins.splice(i, 1);
                    
                    // Update scoreboard immediately after score change
                    updateScoreboard();
                    
                    // Sound and effects
                    playSound(600 + (combo * 50), 150, "sine");
                    createParticles(
                        coin.x * gridSize + gridSize / 2,
                        coin.y * gridSize + gridSize / 2,
                        coin.type === 'golden' ? "#ffd700" : "#ff0", 12
                    );
                    
                    // Show score popup
                    showNotification(`+${points}${combo > 1 ? ` (${combo}x)` : ''}`);
                    
                    // Place a new coin immediately after collecting one
                    placeCoin();
                    checkAchievements();
                    
                    // Bonus life every 50 points
                    if (score > 0 && score % 50 === 0 && lives < maxLives) {
                        grantBonusLife();
                    }
                    
                    // Level progression - check for level up
                    if (newLevel > level && gameMode !== 'timeattack') {
                        // Only level up if we haven't reached the max level
                        if (level < 20) {
                            level = newLevel;
                            speed = Math.max(30, 120 - level * 4);
                            
                            // Special milestone notifications
                            let levelMessage = `Level ${level}!`;
                            if (level === 5) levelMessage = "Level 5 - Getting Warmed Up!";
                            else if (level === 10) levelMessage = "Level 10 - Halfway There!";
                            else if (level === 15) levelMessage = "Level 15 - Expert Territory!";
                            else if (level === 20) levelMessage = "Level 20 - SNAKE MASTER!";
                            
                            showNotification(levelMessage);
                            playSound(800, 300, "sine");
                            
                            // Special effects for milestone levels
                            if (level === 5 || level === 10 || level === 15 || level === 20) {
                                screenShake = 5;
                                createParticles(canvas.width / 2, canvas.height / 2, 
                                    level >= 20 ? "#ffd700" : 
                                    level >= 15 ? "#8a2be2" : 
                                    level >= 10 ? "#ff4500" : "#32cd32", 25);
                            }
                            
                            // Update scoreboard again after level change
                            updateScoreboard();
                        } else if (level >= 20 && !win) {
                            // Player has completed all 20 levels
                            win = true;
                            finalizeGame();
                            return;
                        }
                    }
                    
                    updateScoreboard();
                    break; // Only collect one coin per move
                }
            }

            // Check power-up collision
            powerUps = powerUps.filter(powerUp => {
                if (powerUp.checkCollision(newHead.x, newHead.y)) {
                    applyPowerUp(powerUp.type);
                    createParticles(
                        powerUp.x * gridSize + gridSize / 2,
                        powerUp.y * gridSize + gridSize / 2,
                        "#ff00ff", 15
                    );
                    return false;
                }
                return true;
            });

            // Only remove tail if no coin was collected (this makes snake grow)
            if (!coinCollected) {
                snake.pop();
                // Reset combo only if no coin collected
                if (combo > 0) {
                    combo = 0;
                }
            }
        }

        function finalizeGame() {
            stats.gamesPlayed++;
            if (score > stats.highScore) {
                stats.highScore = score;
            }
            if (snake.length > stats.longestSnake) {
                stats.longestSnake = snake.length;
            }
            
            const playTime = (Date.now() - gameStartTime) / 1000;
            stats.totalPlayTime += playTime;
            
            saveData();
            updateStatsDisplay();
            
            if (win) {
                playAchievementSound();
                createParticles(canvas.width / 2, canvas.height / 2, "#00ff00", 20);
            }
        }

        // Touch controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const touchEndX = touch.clientX - rect.left;
            const touchEndY = touch.clientY - rect.top;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 30) {
                    inputQueue.push({ x: 1, y: 0 }); // Right
                } else if (deltaX < -30) {
                    inputQueue.push({ x: -1, y: 0 }); // Left
                }
            } else {
                // Vertical swipe
                if (deltaY > 30) {
                    inputQueue.push({ x: 0, y: 1 }); // Down
                } else if (deltaY < -30) {
                    inputQueue.push({ x: 0, y: -1 }); // Up
                }
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            if (gameOver || win) {
                if (e.key === 'r' || e.key === 'R') {
                    resetGame();
                    gameLoop();
                }
                return;
            }

            if (e.key === ' ') {
                isPaused = !isPaused;
                pauseOverlay.style.display = isPaused ? 'flex' : 'none';
                if (!isPaused) {
                    // Reset the speed to correct value when unpausing
                    if (activePowerUp === 'speed') {
                        speed = Math.max(20, Math.max(30, 120 - level * 4) - 40);
                    } else if (activePowerUp === 'slow') {
                        speed = Math.max(30, 120 - level * 4) + 40;
                    } else {
                        speed = gameMode === 'timeattack' ? 80 : Math.max(30, 120 - level * 4);
                    }
                    gameLoop();
                }
                return;
            }

            // Direction controls
            let newDirection = null;
            if ((e.key === "ArrowUp" || e.key === "w" || e.key === "W")) {
                newDirection = { x: 0, y: -1 };
            } else if ((e.key === "ArrowDown" || e.key === "s" || e.key === "S")) {
                newDirection = { x: 0, y: 1 };
            } else if ((e.key === "ArrowLeft" || e.key === "a" || e.key === "A")) {
                newDirection = { x: -1, y: 0 };
            } else if ((e.key === "ArrowRight" || e.key === "d" || e.key === "D")) {
                newDirection = { x: 1, y: 0 };
            }

            if (newDirection && inputQueue.length < 3) {
                inputQueue.push(newDirection);
            }
        });

        // Game mode selection
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameMode = btn.dataset.mode;
                resetGame();
                if (!gameOver && !win && !isPaused) {
                    gameLoop();
                }
            });
        });

        // Initialize game
        loadData();
        gameMode = 'classic';
        resetGame();
        gameLoop();
    };
    </script>
</body>